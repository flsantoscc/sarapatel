Package sarapatel;

Helpers
    all = [0..0xFFFF];
    digit = ['0'..'9'];
    non_digit = ['_' + [['a'..'z'] + ['A'..'Z']]];
    nonzero_digit = [digit - '0'];
    binary_digit = '0' | '1';

    binary_constant = '0b' binary_digit+;
    decimal_constant = nonzero_digit digit*;

    tab = 9;
    lf = 10;
    cr = 13;
    eol = cr lf | cr | lf;
    not_cr_lf = [all - [cr + lf]];
    blank = (' ' | tab | eol)+;
    not_lbkt = [all - '}'];
    minus = '-';
    short_comment = '--' not_cr_lf* eol?;
    long_comment = '{' (short_comment | not_lbkt)* '}' eol?;

Tokens
    digit = digit;
    dot = '.';
    comma = ',';
    colon = ':';
    semicolon = ';';
    l_par = '(';
    r_par = ')';
    l_bracket = '[';
    r_bracket = ']';
    star = '*';
    div = '/';
    mod = '%';
    plus = '+';
    minus = minus;
    pipe = '|';

    main_init = '>>';
    attr = '<<';
    e = 'e';
    ou = 'ou';
    nao = 'nao';
    greater = '>';
    greater_equal = '>=';
    equal = '=';
    se = 'se';
    senao = 'senao';
    funcao = 'funcao';
    procedimento = 'procedimento';
    enquanto = 'enquanto';
    comece = 'comece';
    termine = 'termine';
    var = 'var';
    const = 'const';
    imprima = 'imprima';
    leia = 'leia';
    size = 'size';
    principal = 'principal';

    t_inteiro = 'inteiro';
    t_real = 'real';
    t_cadeia = 'cadeia';
    t_booleano = 'booleano';

    floating_constant = nonzero_digit (digit+)? ',' digit+;
    integer_constant = binary_constant | decimal_constant;
    cadeia_constant = ''' [not_cr_lf - ''']+ ''';
    boolean_constant = 'verdade' | 'falso';
    negative_floating_constant = minus nonzero_digit digit+ ',' digit+;
    negative_integer_constant = minus (binary_constant | decimal_constant);

    eol = eol;
    blank = blank;

    id = non_digit (digit | non_digit)*;
    comment = short_comment | long_comment;

Ignored Tokens
    blank,
    comment,
    eol;

Productions
    programa =
        {programa} dec_var_or_const* dec_proc_or_funcao+ dec_proc_principal;

    dec_proc_principal =
        {dec_procedimento} attr procedimento colon principal l_par parametros r_par comece comando termine;

    dec_var_or_const =
        {dec_var} dec_var   |
        {dec_const} dec_cons;

    dec_proc_or_funcao =
        {dec_proc} dec_procedimento |
        {dec_funcao} dec_funcao     ;

    dec_var =
        {dec_var} var colon tipo id_or_id_atribuicao semicolon;

    dec_cons =
        {dec_cons} const colon tipo id attr exp semicolon;

    id_or_id_atribuicao =
        {id} id                      |
        {id_atribuicao} id attr exp;

    tipo =
        {tipo_base} tipo_base |
        {tipo_brkt} tipo l_bracket exp r_bracket;

    tipo_base =
        {inteiro} t_inteiro |
        {booleano} t_booleano |
        {real} t_real |
        {cadeia} t_cadeia;

    array_comp =
        {array_comp} l_bracket id pipe exp r_bracket;

    dec_procedimento =
        {dec_procedimento} attr? procedimento colon id l_par parametros r_par comece comando termine;

    dec_funcao =
        {dec_funcao} funcao colon tipo id l_par parametros r_par exp comece termine;

    parametros =
        {parametros} parametros_aux?;

    parametros_aux =
        {pipe_parametro_closure} parametro pipe_parametro*;

    pipe_parametro =
        {pipe_parametro} pipe parametro;

    parametro =
        {parametro} tipo_parametro id;

    tipo_parametro =
        {tipo_base} tipo_base |
        {tipo_parametro_brkt} tipo_parametro l_bracket r_bracket;

    comando =
        {se_comando} se l_par exp r_par comando semicolon                          |
        {se_senao_comando} se l_par exp r_par [left]:comando senao [right]:comando |
        {enquanto} enquanto l_par exp r_par comando                                |
        {id_atribuicao} id attr exp semicolon                                      |
        {chamada_proc} chamada_procedimento semicolon                              |
        {bloco_comandos} bloco_comandos                                            ;

    bloco_comandos =
        {bloco_comandos} comece dec_var_or_const* comando* termine;

    valor =
        {id} id                                    |
        {valor_brkts} valor l_bracket exp r_bracket;

    bloco_expressoes =
        {bloco_expressoes} comece dec_cons* exp termine;

    chamada_funcao =
        {chamada_funcao} id l_par lista_exp r_par;

    chamada_procedimento =
        {chamada_procedimento} l_par lista_exp r_par;

    lista_exp =
        {lista_exp} lista_exp_aux?;

    lista_exp_aux =
        {aux} exp pipe_exp*;

    pipe_exp =
        {pipe_exp} pipe exp;


    number =
        {integer} integer_constant |
        {real} floating_constant   ;

    boolean_exp =
        {boolean} boolean_constant;

    cadeia_exp =
        {cadeia} cadeia_constant;

    literal =
            {integer} integer_constant |
            {real} floating_constant   |
            {boolean} boolean_constant |
            {cadeia} cadeia_constant   ;

    multiplicative_exp =
        {multiplication} multiplicative_exp star number |
        {number} number                                 ;

    dividitive_exp =
        {division} multiplicative_exp div number;

    mod_exp =
        {mod} multiplicative_exp mod number;

    additive_exp =
        {additive_exp} additive_exp plus dividitive_exp;

    subtractive_exp =
        {subtractive_exp} additive_exp minus dividitive_exp;

    exp =
        {boolean_exp} boolean_exp                                        |
        {cadeia_exp} cadeia_exp                                          |
        {valor} valor                                                    |
        {sorrounded_exp} l_par exp r_par                                 |
        {chamada_funcao} chamada_funcao                                  |
        {array_comp} array_comp                                          |
        {minus_exp} minus number                                         |
        {subtractive_exp} subtractive_exp                                |
        {mod_exp} mod_exp number                                         |
        {equal_exp} exp equal literal                                    |
        {greater} exp greater number                                     |
        {greater_equal} exp greater_equal number                         |
        {not} nao boolean_exp                                            |
        {and} exp e boolean_exp                                          |
        {or}  exp ou boolean_exp                                         |
        {bloco_expressoes} bloco_expressoes                              ;