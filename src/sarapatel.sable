Package sarapatel;

Helpers
    letter = ['a' .. 'z'] | ['A' .. 'Z'];
    under = '_';
    digit = ['0' .. '9'];
    sp = ' ';
    rc = 13;
    nl = 10;
    tab = 9;
    eof = (nl | rc | rc nl);
    all = [0 .. 0xFFFF];
    all_no_rc_nl = [all - [rc + nl]];
    all_no_braces = [[all - '{'] - '}'];
    all_no_apos = [all - '''];

Tokens
     // Keywords
     var = 'var';
     const = 'const';
     se = 'se';
     senao = 'senao';
     enquanto = 'enquanto';
     funcao = 'funcao';
     procedimento = 'procedimento';
     e = 'e';
     ou = 'ou';
     negacao = 'nao';
     comece = 'comece';
     termine = 'termine';

     // Type Keywords
     int_kw = 'inteiro';
     float_kw = 'real';
     string_kw = 'cadeia';
     bool_kw = 'booleano';

     // Primitive Types
     int = (('-')? digit+) | ('0b' ('1' | '0')+);
     float = ('-')? digit+ ',' digit+;
     string = ''' all_no_apos* ''';
     bool = 'verdade' | 'falso';

     // Operators
     plus = '+';
     minus = '-';
     star = '*';
     div = '/';
     mod = '%';
     greater = '>';
     greater_eq = '>=';
     equal = '=';
     l_par = '(';
     r_par = ')';
     l_brkt = '[';
     r_brkt = ']';

     // Declarators
     dd = '<<';
     main_init = '>>';
     semi = ';';
     pipe = '|';
     colon = ':';

     // Misc
     id = (under|letter) (under|letter|digit)*;
     comment = '{' all_no_braces* '}';
     ml_comment = '--' all_no_rc_nl* (eof)?;
     blank = (rc | nl | sp | tab)+;

Ignored Tokens
    blank, comment, ml_comment;

Productions
    programa {-> P.programa  } =
        {aprograma1} P.dec_proc_or_func                    {-> New programa ([], [dec_proc_or_func.dec_proc_or_func])}                                  |
        {aprograma2} P.dec_var_or_const P.dec_proc_or_func {-> New programa ([dec_var_or_const.dec_var_or_const], [dec_proc_or_func.dec_proc_or_func])} ;

    dec_proc_or_func {-> P.dec_proc_or_func  } =
        {proc} dec_proc {-> New dec_proc_or_func.proc (dec_proc)} |
        {func} dec_func {-> New dec_proc_or_func.func (dec_func)} ;

    dec_var_or_const {-> P.dec_var_or_const  } =
        {var} dec_var     {-> New dec_var_or_const.var (dec_var)}     |
        {const} dec_const {-> New dec_var_or_const.const (dec_const)} ;

    dec_var{-> P.dec_var} = var colon tipo id_dec semi {-> New dec_var (tipo, id_dec)};

    dec_const {-> P.dec_const  } = const colon tipo attr semi {-> New dec_const (tipo , attr)};

    id_dec {-> P.id_dec  } =
        {id} id       {-> New id_dec.id (id)}       |
        {id_atr} attr {-> New id_dec.id_atr (attr)} ;

    dec_proc { -> dec_proc } =
        {adecproc1} procedimento colon id l_par r_par comando                 { -> New dec_proc.adecproc1(id, comando)}         |
        {adecproc2} main_init procedimento colon id l_par r_par comando       { -> New dec_proc.adecproc2(id, comando)}         |
        {adecproc3} procedimento colon id l_par param r_par comando           { -> New dec_proc.adecproc3(id, param, comando) } |
        {adecproc4} main_init procedimento colon id l_par param r_par comando { -> New dec_proc.adecproc4(id, param, comando) } ;

    dec_func { -> P.dec_func } =
        {adecfunc1} funcao colon tipo_func id l_par r_par exp       { -> New dec_func.adecfunc1(tipo_func, id , exp) }       |
        {adecfunc2} funcao colon tipo_func id l_par param r_par exp { -> New dec_func.adecfunc2(tipo_func, id, param, exp) } ;

    chamada_funcao {-> P.chamada_funcao} =
        {achamadafuncao1} id l_par r_par          { -> New chamada_funcao.achamadafuncao1(id)}           |
        {achamadafuncao2} id l_par exp_list r_par { -> New chamada_funcao.achamadafuncao2(id, exp_list)} ;

    chamada_procedimento {-> P.chamada_procedimento} =
        {achamadaprocedimento1} id l_par r_par          { -> New chamada_procedimento.achamadaprocedimento1(id)}           |
        {achamadaprocedimento2} id l_par exp_list r_par { -> New chamada_procedimento.achamadaprocedimento2(id, exp_list)} ;

    tipo {-> P.tipo  } =
        {base} tipo_kw               { -> New tipo.base(tipo_kw)}   |
        {arr} tipo l_brkt exp r_brkt { -> New tipo.arr(tipo, exp) } ;

    tipo_func {-> P.tipo_func} =
        {base} tipo_kw                { -> New tipo_func.base(tipo_kw)}  |
        {arr} tipo_func l_brkt r_brkt { -> New tipo_func.arr(tipo_func)} ;

    tipo_kw{-> P.tipo_kw} =
        {int} int_kw       { -> New tipo_kw.int(int_kw)}       |
        {bool} bool_kw     { -> New tipo_kw.bool(bool_kw)}     |
        {real} float_kw    { -> New tipo_kw.real(float_kw)}    |
        {cadeia} string_kw { -> New tipo_kw.cadeia(string_kw)} ;

    attr {-> P.attr} =
        id dd exp { -> New attr(id, exp)};

    arr_attr {-> P.arr_attr} =
        {id} id { -> New arr_attr.id(id)} |
        {arr} arr_attr l_brkt exp r_brkt { -> New arr_attr.arr(arr_attr, exp)};

    array_comp {-> P.array_comp} =
        l_brkt id pipe exp r_brkt {-> New array_comp(id, exp)};

    parametro {-> P.parametro} =
        tipo_param id { -> New parametro(tipo_param, id)};

    param {-> P.param  } =
        {aparam1} parametro              { -> New param(parametro, [])}                      |
        {aparam2} parametro P.pipe_param { -> New param(parametro, [ pipe_param.pipe_param])};

    pipe_param {-> P.pipe_param  } =
        pipe parametro {-> New pipe_param(parametro)};

    tipo_param {-> P.tipo_param  } =
        {par} tipo_kw                      { -> New tipo_param.par(tipo_kw)}        |
        {arr_par} tipo_param l_brkt r_brkt { -> New tipo_param.arr_par(tipo_param)} ;

    comando {-> P.comando} =
        {se} se l_par exp r_par comando                         { -> New comando.se(exp, comando)}                                |
        {se_senao} se l_par exp r_par comando_aux senao comando { -> New comando.se_senao(exp, comando_aux, comando)}             |
        {enquanto} enquanto l_par exp r_par comando             { -> New comando.enquanto(exp, comando)}                          |
        {attr} arr_attr dd exp semi                             { -> New comando.attr(arr_attr, exp)}                             |
        {proc} chamada_procedimento semi                        { -> New comando.proc(chamada_procedimento, semi)}                |
        {ablococomando1} comece termine                         { -> New comando.bloco([], [])}                                   |
        {ablococomando2} comece P.sub_bloco termine             { -> New comando.bloco([sub_bloco.sub_bloco], [])}                |
        {ablococomando3} comece P.comando termine               { -> New comando.bloco([], [comando.comando])}                    |
        {ablococomando4} comece P.sub_bloco P.comando termine   { -> New comando.bloco([sub_bloco.sub_bloco], [comando.comando])} ;

    comando_aux {-> P.comando_aux  } =
        {se} se l_par exp r_par [then]: comando_aux senao [else]: comando_aux { -> New comando_aux.se(exp, then, else)}                             |
        {enquanto} enquanto l_par exp r_par comando_aux                       { -> New comando_aux.enquanto(exp, comando_aux)}                      |
        {proc} chamada_procedimento semi                                      { -> New comando_aux.proc(chamada_procedimento)}                      |
        {attr} arr_attr dd exp semi                                           { -> New comando_aux.attr(arr_attr, exp)}                             |
        {ablococomandoaux1} comece termine                                    { -> New comando_aux.bloco([], [])}                                   |
        {ablococomandoaux2} comece P.sub_bloco termine                        { -> New comando_aux.bloco([sub_bloco.sub_bloco], [])}                |
        {ablococomandoaux3} comece P.comando termine                          { -> New comando_aux.bloco([], [comando.comando])}                    |
        {ablococomandoaux4} comece P.sub_bloco P.comando termine              { -> New comando_aux.bloco([sub_bloco.sub_bloco], [comando.comando])} ;

    sub_bloco { -> P.sub_bloco } =
        {var} dec_var     {-> New sub_bloco.var(dec_var)}     |
        {const} dec_const {-> New sub_bloco.const(dec_const)} ;

    valor { -> P.valor } =
        {id} id                       {-> New valor.id(id)}          |
        {exp} valor l_brkt exp r_brkt {-> New valor.exp(valor ,exp)} ;

    exp_list { -> P.exp_list } =
        {aexplist1} exp            {-> New exp_list(exp , [])}                 |
        {aexplist2} exp P.pipe_exp {-> New exp_list(exp, [pipe_exp.pipe_exp])} ;

    pipe_exp { -> P.pipe_exp } =
        {pipe_exp} pipe exp {-> New pipe_exp.pipe_exp(pipe , exp)};

    exp { -> exp } =
        {array_c} array_comp                                           { -> New exp.array_c(array_comp) }                |
        {b_exp} comece dec_const* exp termine                          { -> New exp.b_exp([dec_const.dec_const], exp) }  |
        {se_exp} se l_par [if]:exp r_par [then]:exp senao [else]:value { -> New exp.se_exp(if.exp, then.exp, else.exp) } |
        {ou} [left]:exp ou [right]:value                               { -> New exp.ou(left.exp, right.exp) }            |
        {e} [left]:exp e [right]:value                                 { -> New exp.e(left.exp, right.exp)}              |
        {equal} [left]:exp equal [right]:value                         { -> New exp.equal(left.exp, right.exp) }         |
        {greater_eq} [left]:exp greater_eq [right]:value               { -> New exp.greater_eq(left.exp, right.exp) }    |
        {greater} [left]:exp greater [right]:value                     { -> New exp.greater(left.exp, right.exp) }       |
        {soma} [left]:exp plus [right]:value                           { -> New exp.soma(left.exp, right.exp) }          |
        {sub} [left]:exp minus [right]:value                           { -> New exp.minus(left.exp, right.exp) }         |
        {mult}[left]:exp star [right]:value                            { -> New exp.mult(left.exp, right.exp) }          |
        {div} [left]:exp div [right]:value                             { -> New exp.div(left.exp, right.exp) }           |
        {mod} [left]:exp mod [right]:value                             { -> New exp.mod(left.exp, right.exp) }           |
        {incremento} plus value                                        { -> New exp.incremento(value.exp) }              |
        {decremento} minus value                                       { -> New exp.decremento(value.exp) }              |
        {negacao} negacao value                                        { -> New exp.negacao(value.exp) }                 |
        {value} value                                                  { -> value.exp }                                  ;


    value { -> exp } =
        {int} int                { -> New exp.int(int) }               |
        {bool} bool              { -> New exp.bool(bool) }             |
        {real} float             { -> New exp.real(float) }            |
        {cadeia} string          { -> New exp.cadeia(string) }         |
        {valor} valor            { -> New exp.valor(valor) }           |
        {par} l_par exp r_par    { -> New exp.par(exp) }               |
        {c_func} chamada_funcao  { -> New exp.c_func(chamada_funcao) } ;
    
        
Abstract Syntax Tree
    programa = dec_var_or_const* dec_proc_or_func+;

    dec_proc_or_func =
        {proc} dec_proc |
        {func} dec_func ;

    dec_var_or_const =
        {var} dec_var    |
        {const} dec_const;

    dec_var = tipo id_dec;

    dec_const = tipo attr;

    id_dec =
        {id} id      |
        {id_atr} attr;

    dec_proc = 
        {adecproc1} id comando       |
        {adecproc2} id comando       |
        {adecproc3} id param comando |
        {adecproc4} id param comando ;

    dec_func = 
        {adecfunc1} tipo_func id exp       |
        {adecfunc2} tipo_func id param exp ;

    chamada_funcao = 
        {achamadafuncao1} id          |
        {achamadafuncao2} id exp_list ;

    chamada_procedimento = 
        {achamadaprocedimento1} id          |
        {achamadaprocedimento2} id exp_list ;

    tipo =
        {base} tipo_kw |
        {arr} tipo exp ;

    tipo_func =
        {base} tipo_kw  |
        {arr} tipo_func ;

    tipo_kw =
        {int} int_kw       |
        {bool} bool_kw     |
        {real} float_kw    |
        {cadeia} string_kw ;

    attr = id exp;

    arr_attr =
        {id} id            |
        {arr} arr_attr exp ;

    array_comp = id exp;

    parametro = tipo_param id;

    param =parametro pipe_param*;

    pipe_param = parametro;

    tipo_param =
        {par} tipo_kw        |
        {arr_par} tipo_param ;

    comando =
        {se} exp comando                   |
        {se_senao} exp comando_aux comando |
        {enquanto} exp comando             |
        {attr} arr_attr exp                |
        {proc} chamada_procedimento semi   |
        {bloco} sub_bloco* comando*        ;

    comando_aux =
        {se} exp [then]:comando_aux [else]:comando_aux |
        {enquanto} exp comando_aux                     |
        {proc} chamada_procedimento                    |
        {attr} arr_attr exp                            |
        {bloco} sub_bloco* comando*                    ;

    sub_bloco =
        {var} dec_var     |
        {const} dec_const ;

    valor =
        {id} id         |
        {exp} valor exp ;

    exp_list = exp pipe_exp*;

    pipe_exp = {pipe_exp} pipe exp;

    dec_const_list = 
        {single} exp                            |                      
        {multiple} exp dec_const dec_const_list ;

    bloco_expressoes = comece dec_const* exp termine;

    exp =
        {int} int                               |
        {bool} bool                             |
        {real} float                            |
        {cadeia} string                         |
        {valor} valor                           |
        {c_func} chamada_funcao                 |
        {array_c} array_comp                    |
        {incremento} exp                        |
        {decremento} exp                        |
        {se_exp} [if]:exp [then]:exp [else]:exp |
        {soma} [left]:exp [right]:exp           |
        {minus} [left]:exp [right]:exp          |
        {mult} [left]:exp [right]:exp           |
        {div} [left]:exp [right]:exp            |
        {mod} [left]:exp [right]:exp            |
        {equal} [left]:exp [right]:exp          |
        {greater_eq} [left]:exp [right]:exp     |
        {greater} [left]:exp [right]:exp        |
        {e} [left]:exp [right]:exp              |
        {ou} [left]:exp [right]:exp             | 
        {par} exp                               |
        {negacao} exp                           |
        {b_exp} [dc_cons]:dec_const* exp        ;