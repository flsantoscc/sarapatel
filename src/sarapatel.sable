Package sarapatel;

Helpers
    letter = ['a' .. 'z'] | ['A' .. 'Z'];
    under = '_';
    digit = ['0' .. '9'];
    sp = ' ';
    rc = 13;
    nl = 10;
    tab = 9;
    eof = (nl | rc | rc nl);
    all = [0 .. 0xFFFF];
    all_no_rc_nl = [all - [rc + nl]];
    all_no_braces = [[all - '{'] - '}'];
    all_no_apos = [all - '''];

Tokens
     // Keywords
     var = 'var';
     const = 'const';
     se = 'se';
     senao = 'senao';
     enquanto = 'enquanto';
     funcao = 'funcao';
     procedimento = 'procedimento';
     e = 'e';
     ou = 'ou';
     negacao = 'nao';
     comece = 'comece';
     termine = 'termine';

     // Type Keywords
     int_kw = 'inteiro';
     float_kw = 'real';
     string_kw = 'cadeia';
     bool_kw = 'booleano';

     // Primitive Types
     int = (('-')? digit+) | ('0b' ('1' | '0')+);
     float = ('-')? digit+ ',' digit+;
     string = ''' all_no_apos* ''';
     bool = 'verdade' | 'falso';

     // Operators
     plus = '+';
     minus = '-';
     star = '*';
     div = '/';
     mod = '%';
     greater = '>';
     greater_eq = '>=';
     equal = '=';
     l_par = '(';
     r_par = ')';
     l_brkt = '[';
     r_brkt = ']';

     // Declarators
     dd = '<<';
     main_init = '>>';
     semi = ';';
     pipe = '|';
     colon = ':';

     // Misc
     id = (under|letter) (under|letter|digit)*;
     comment = '{' all_no_braces* '}';
     ml_comment = '--' all_no_rc_nl* (eof)?;
     blank = (rc | nl | sp | tab)+;

Ignored Tokens
    blank, comment, ml_comment;

Productions
    programa { -> P.programa  } =
        {aprograma1} P.dec_proc             { -> New programa.aprograma1([P.dec_proc])}                |
        {aprograma2} P.dec_func             { -> New programa.aprograma2([P.dec_func])}                |
        {aprograma3} P.dec_var P.dec_proc   { -> New programa.aprograma3([P.dec_var], [P.dec_proc])}   |
        {aprograma4} P.dec_const P.dec_func { -> New programa.aprograma4([P.dec_const], [P.dec_func])} ;

    dec_var { -> P.dec_var } = 
        {dec_var1} var colon tipo id semi { -> New dec_var.dec_var1(tipo, id) }   |
        {dec_var2} var colon tipo attr semi { -> New dec_var.dec_var2(tipo, attr)};
        
    dec_const { -> P.dec_const  } = const colon tipo attr semi {-> New dec_const (tipo , attr)};

    dec_proc { -> dec_proc } =
        {adecproc1} procedimento colon id l_par r_par comando                 { -> New dec_proc.adecproc1(id, comando)}         |
        {adecproc2} main_init procedimento colon id l_par r_par comando       { -> New dec_proc.adecproc2(id, comando)}         |
        {adecproc3} procedimento colon id l_par param r_par comando           { -> New dec_proc.adecproc3(id, param, comando) } |
        {adecproc4} main_init procedimento colon id l_par param r_par comando { -> New dec_proc.adecproc4(id, param, comando) } ;

    dec_func { -> P.dec_func } =
        {adecfunc1} funcao colon tipo_func id l_par r_par exp       { -> New dec_func.adecfunc1(tipo_func, id , exp) }       |
        {adecfunc2} funcao colon tipo_func id l_par param r_par exp { -> New dec_func.adecfunc2(tipo_func, id, param, exp) } ;

    chamada_funcao {-> P.chamada_funcao} =
        {achamadafuncao1} id l_par r_par          { -> New chamada_funcao.achamadafuncao1(id)}           |
        {achamadafuncao2} id l_par exp_list r_par { -> New chamada_funcao.achamadafuncao2(id, exp_list)} ;

    chamada_procedimento {-> P.chamada_procedimento} =
        {achamadaprocedimento1} id l_par r_par          { -> New chamada_procedimento.achamadaprocedimento1(id)}           |
        {achamadaprocedimento2} id l_par exp_list r_par { -> New chamada_procedimento.achamadaprocedimento2(id, exp_list)} ;

    tipo {-> P.tipo  } =
        {base} tipo_kw               { -> New tipo.base(tipo_kw)}   |
        {arr} tipo l_brkt exp r_brkt { -> New tipo.arr(tipo, exp) } ;

    tipo_func {-> P.tipo_func} =
        {base} tipo_kw                { -> New tipo_func.base(tipo_kw)}  |
        {arr} tipo_func l_brkt r_brkt { -> New tipo_func.arr(tipo_func)} ;

    tipo_kw{-> P.tipo_kw} =
        {int} int_kw       { -> New tipo_kw.int(int_kw)}       |
        {bool} bool_kw     { -> New tipo_kw.bool(bool_kw)}     |
        {real} float_kw    { -> New tipo_kw.real(float_kw)}    |
        {cadeia} string_kw { -> New tipo_kw.cadeia(string_kw)} ;

    attr {-> P.attr} =
        id dd exp { -> New attr(id, exp)};

    arr_attr {-> P.arr_attr} =
        {id} id { -> New arr_attr.id(id)} |
        {arr} arr_attr l_brkt exp r_brkt { -> New arr_attr.arr(arr_attr, exp)};

    array_comp {-> P.array_comp} =
        l_brkt id pipe exp r_brkt {-> New array_comp(id, exp)};

    parametro {-> P.parametro} =
        tipo_param id { -> New parametro(tipo_param, id)};

    param {-> P.param  } =
        {aparam1} parametro              { -> New param(parametro, [])}                      |
        {aparam2} parametro P.pipe_param { -> New param(parametro, [ pipe_param.pipe_param])};

    pipe_param {-> P.pipe_param  } =
        pipe parametro {-> New pipe_param(parametro)};

    tipo_param {-> P.tipo_param  } =
        {par} tipo_kw                      { -> New tipo_param.par(tipo_kw)}        |
        {arr_par} tipo_param l_brkt r_brkt { -> New tipo_param.arr_par(tipo_param)} ;

    comando {-> P.comando} =
        {se} se l_par exp r_par comando                           { -> New comando.se(exp, comando)}                            |
        {se_senao} se l_par exp r_par comando_aux senao comando   { -> New comando.se_senao(exp, comando_aux, comando)}         |
        {enquanto} enquanto l_par exp r_par comando               { -> New comando.enquanto(exp, comando)}                      |
        {attr} arr_attr dd exp semi                               { -> New comando.attr(arr_attr, exp)}                         |
        {proc} chamada_procedimento semi                          { -> New comando.proc(chamada_procedimento)}                  |
        {bloco_vazio} comece termine                              { -> New comando.bloco_var([], [])}                           |
        {bloco_var} comece dec_var termine                        { -> New comando.bloco_var([dec_var], [])}                    |
        {bloco_const} comece dec_const termine                    { -> New comando.bloco_const([dec_const], [])}                |
        {bloco_comando} comece P.comando termine                  { -> New comando.bloco_var([], [comando.comando])}            |
        {bloco_var_comando} comece dec_var P.comando termine      { -> New comando.bloco_var([dec_var], [comando.comando])}     |
        {bloco_const_comando} comece dec_const P.comando termine  { -> New comando.bloco_const([dec_const], [comando.comando])} ;

    comando_aux {-> P.comando_aux  } =
        {se} se l_par exp r_par [then]: comando_aux senao [else]: comando_aux { -> New comando_aux.se(exp, then, else)}                         |
        {enquanto} enquanto l_par exp r_par comando_aux                       { -> New comando_aux.enquanto(exp, comando_aux)}                  |
        {proc} chamada_procedimento semi                                      { -> New comando_aux.proc(chamada_procedimento)}                  |
        {attr} arr_attr dd exp semi                                           { -> New comando_aux.attr(arr_attr, exp)}                         |
        {bloco_vazio} comece termine                                          { -> New comando_aux.bloco_var([], [])}                           |
        {bloco_var} comece dec_var termine                                    { -> New comando_aux.bloco_var([dec_var], [])}                    |
        {bloco_const} comece dec_const termine                                { -> New comando_aux.bloco_const([dec_const], [])}                |
        {bloco_comando} comece P.comando termine                              { -> New comando_aux.bloco_var([], [comando.comando])}            |
        {bloco_var_comando} comece dec_var P.comando termine                  { -> New comando_aux.bloco_var([dec_var], [comando.comando])}     |
        {bloco_const_comando} comece dec_const P.comando termine              { -> New comando_aux.bloco_const([dec_const], [comando.comando])} ;


    valor { -> P.valor } =
        {id} id                       {-> New valor.id(id)}          |
        {exp} valor l_brkt exp r_brkt {-> New valor.exp(valor ,exp)} ;

    exp_list { -> P.exp_list } =
        {aexplist1} exp            {-> New exp_list(exp, [])}         |
        {aexplist2} exp P.pipe_exp {-> New exp_list(exp, [pipe_exp])} ;

    pipe_exp { -> P.pipe_exp } =
        {pipe_exp} pipe exp {-> New pipe_exp(exp)};

    exp { -> exp } =
        {array_c} array_comp                                           { -> New exp.array_c(array_comp) }                |
        {b_exp} comece dec_const* exp termine                          { -> New exp.b_exp([dec_const.dec_const], exp) }  |
        {se_exp} se l_par [if]:exp r_par [then]:exp senao [else]:value { -> New exp.se_exp(if.exp, then.exp, else.exp) } |
        {ou} [left]:exp ou [right]:value                               { -> New exp.ou(left.exp, right.exp) }            |
        {e} [left]:exp e [right]:value                                 { -> New exp.e(left.exp, right.exp)}              |
        {equal} [left]:exp equal [right]:value                         { -> New exp.equal(left.exp, right.exp) }         |
        {greater_eq} [left]:exp greater_eq [right]:value               { -> New exp.greater_eq(left.exp, right.exp) }    |
        {greater} [left]:exp greater [right]:value                     { -> New exp.greater(left.exp, right.exp) }       |
        {soma} [left]:exp plus [right]:value                           { -> New exp.soma(left.exp, right.exp) }          |
        {sub} [left]:exp minus [right]:value                           { -> New exp.minus(left.exp, right.exp) }         |
        {mult}[left]:exp star [right]:value                            { -> New exp.mult(left.exp, right.exp) }          |
        {div} [left]:exp div [right]:value                             { -> New exp.div(left.exp, right.exp) }           |
        {mod} [left]:exp mod [right]:value                             { -> New exp.mod(left.exp, right.exp) }           |
        {incremento} plus value                                        { -> New exp.incremento(value.exp) }              |
        {decremento} minus value                                       { -> New exp.decremento(value.exp) }              |
        {negacao} negacao value                                        { -> New exp.negacao(value.exp) }                 |
        {value} value                                                  { -> value.exp }                                  ;


    value { -> exp } =
        {int} int                { -> New exp.int(int) }               |
        {bool} bool              { -> New exp.bool(bool) }             |
        {real} float             { -> New exp.real(float) }            |
        {cadeia} string          { -> New exp.cadeia(string) }         |
        {valor} valor            { -> New exp.valor(valor) }           |
        {par} l_par exp r_par    { -> New exp.par(exp) }               |
        {c_func} chamada_funcao  { -> New exp.c_func(chamada_funcao) } ;
    
        
Abstract Syntax Tree
    programa =
        {aprograma1} P.dec_proc+              |
        {aprograma2} P.dec_func+              |
        {aprograma3} P.dec_var* P.dec_proc+   |
        {aprograma4} P.dec_const* P.dec_func+ ;

    dec_var = 
        {dec_var1} tipo id   |
        {dec_var2} tipo attr ;

    dec_const = tipo attr;

    dec_proc = 
        {adecproc1} id comando       |
        {adecproc2} id comando       |
        {adecproc3} id param comando |
        {adecproc4} id param comando ;

    dec_func = 
        {adecfunc1} tipo_func id exp       |
        {adecfunc2} tipo_func id param exp ;

    chamada_funcao = 
        {achamadafuncao1} id          |
        {achamadafuncao2} id exp_list ;

    chamada_procedimento = 
        {achamadaprocedimento1} id          |
        {achamadaprocedimento2} id exp_list ;

    tipo =
        {base} tipo_kw |
        {arr} tipo exp ;

    tipo_func =
        {base} tipo_kw  |
        {arr} tipo_func ;

    tipo_kw =
        {int} int_kw       |
        {bool} bool_kw     |
        {real} float_kw    |
        {cadeia} string_kw ;

    attr = id exp;

    arr_attr =
        {id} id            |
        {arr} arr_attr exp ;

    array_comp = id exp;

    parametro = tipo_param id;

    param =parametro pipe_param*;

    pipe_param = parametro;

    tipo_param =
        {par} tipo_kw        |
        {arr_par} tipo_param ;

    comando =
        {se} exp comando                   |
        {se_senao} exp comando_aux comando |
        {enquanto} exp comando             |
        {attr} arr_attr exp                |
        {proc} chamada_procedimento        |
        {bloco_var} dec_var* comando*      |
        {bloco_const} dec_const* comando*  ;

    comando_aux =
        {se} exp [then]:comando_aux [else]:comando_aux |
        {enquanto} exp comando_aux                     |
        {proc} chamada_procedimento                    |
        {attr} arr_attr exp                            |
        {bloco_var} dec_var* comando*                  |
        {bloco_const} dec_const* comando*              ;

    valor =
        {id} id         |
        {exp} valor exp ;

    exp_list = exp pipe_exp*;

    pipe_exp = exp;

    exp =
        {int} int                               |
        {bool} bool                             |
        {real} float                            |
        {cadeia} string                         |
        {valor} valor                           |
        {c_func} chamada_funcao                 |
        {array_c} array_comp                    |
        {incremento} exp                        |
        {decremento} exp                        |
        {se_exp} [if]:exp [then]:exp [else]:exp |
        {soma} [left]:exp [right]:exp           |
        {minus} [left]:exp [right]:exp          |
        {mult} [left]:exp [right]:exp           |
        {div} [left]:exp [right]:exp            |
        {mod} [left]:exp [right]:exp            |
        {equal} [left]:exp [right]:exp          |
        {greater_eq} [left]:exp [right]:exp     |
        {greater} [left]:exp [right]:exp        |
        {e} [left]:exp [right]:exp              |
        {ou} [left]:exp [right]:exp             | 
        {par} exp                               |
        {negacao} exp                           |
        {b_exp} [dc_cons]:dec_const* exp        ;